Core Abstractions

Note that methods can be incomplete, or can change, it's rather a rough guideline than a strict instruction

1. Strand
	•	Enum: PLUS, MINUS, UNKNOWN, AGNOSTIC
	•	Provides .flip(), .is_known(), .is_agnostic()

⸻

2. GenomicInterval
	•	Represents a single interval:
	•	chrom: str
	•	start: int
	•	end: int
	•	strand: Strand
	•	Methods:
	•	.length()
	•	.intersects(other: GenomicInterval)
	•	.overlap(other: GenomicInterval)
	•	.flip_strand()

⸻

3. Gene
	•	Holds:
	•	gene_id: str
	•	gene_name: str
	•	chrom: str
	•	strand: Strand
	•	transcripts: list[Transcript]
	•	Method to summarize coordinates, e.g. .bounds() returns the union of all transcripts.

⸻

4. Transcript
	•	Belongs to a Gene
	•	Holds:
	•	transcript_id: str
	•	chrom: str
	•	strand: Strand
	•	exons: np.ndarray of [start, end]
	•	cds_start: int
	•	cds_end: int
	•	Methods:
	•	.cds_blocks() → lazily computed CDS intervals, cached
	•	.utr5_blocks(), .utr3_blocks()
	•	.introns() → computed via exon zig-zag
	•	.length()

⸻

5. AnnotationCollection
	•	A collection of Genes, with fast index:
	•	chrom → strand → list of Gene
	•	Methods:
	•	.filter_by_chrom(chrom)
	•	.find_overlaps(interval)
	•	.map(func)
	•	.summary()
	•	.genes / .transcripts — direct access lists

⸻

6. AlignmentChain
	•	Maps query to target genome.
	•	Fields:
	•	q_chrom, t_chrom
	•	q_strand, t_strand
	•	score: int
	•	blocks: np.ndarray shape (N, 6):
	•	q_start, q_end, q_len, t_start, t_end, t_len
	•	metadata: dict
	•	Methods:
	•	.map_position(pos)
	•	.map_interval(interval)
	•	.extract_subchain(subinterval)

⸻

7. AlignmentChains
	•	Collection of multiple AlignmentChain
	•	Internally stored as:
	•	blocks matrix
	•	index array: per chain start/end
	•	metadata array
	•	Methods:
	•	.save(path)
	•	.load(path)
	•	.find_by_chromosome(q_chrom, t_chrom)

⸻

8. SequenceStore
	•	Interface to access sequence data (via 2bit or other formats)
	•	Holds:
	•	chrom sizes
	•	source backend (e.g. py2bit, twobitreader)
	•	Methods:
	•	.fetch(chrom, start, end, strand)
	•	.chrom_sizes()
	•	.chrom_names()

⸻

9. Raw Records (I/O layer only)
	•	RawBedRecord, RawGenePredRecord, etc.
	•	Just parsed fields, no logic.
	•	Then converted into structured models (e.g. Transcript, Gene).

Sequence Abstractions — Concentrated Plan

⸻

1. NucleotideSequence
	•	Stores int8 numpy array with:
A: +1
G: -1
C: +2
T: -2
N: 0

	Attributes:
	•	is_rna: bool (T → U in rendering)
	•	metadata: dict
	•	Methods:
	•	.reverse_complement()
	•	.transcribe()
	•	.to_string()

⸻

2. CodonSequence
	•	Wraps a NucleotideSequence, chunked into triplets.
	•	Fields:
	•	codons: (N, 3) np.ndarray
	•	incomplete_codon: Optional[np.ndarray]
	•	Methods:
	•	.starts_with_start_codon()
	•	.ends_with_stop_codon()
	•	.has_inframe_stops() → returns positions + codon
	•	.translate(translation_table) → AminoAcidSequence

⸻

3. AminoAcidSequence
	•	uint8 numpy array encoding:
	•	0: Stop
	•	1-26: A-Z letter index (A=1, B=2, …, Z=26)
	•	23: ‘X’ (unknown/ambiguous)
	•	Methods:
	•	.to_string()
	•	.has_stop()
	•	.length()

⸻

4. TranslationTable
	•	Maps codon triplets (on encoded nucleotides) → AA code.
	•	Provides:
	•	standard()
	•	get(table_id)
	•	.is_start_codon(codon)
	•	.is_stop_codon(codon)

⸻

5. TwoBitAccessor
	•	Reads from .2bit, returns NucleotideSequence
	•	Handles:
	•	strand
	•	chrom size validation
	•	masking if needed

TwoBitAccessor → NucleotideSequence → CodonSequence → AminoAcidSequence
All efficient, numeric, low-memory footprint, no strings internally until rendering.