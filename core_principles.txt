Design reference + something for Cursor. 

API Surface Documentation — Core Principle
	•	Documentation must be generated automatically from docstrings via a script.
	•	Docstrings must be extremely brief, optimized for minimal space in an LLM context window.
	•	Obvious behaviors (e.g., to_fasta()) must not be described.
	•	Method and class names should be self-documenting.
	•	Class docstrings: max 3-4 lines.
	•	Method docstrings: 1-2 lines max, ideally none if the name is clear.
	•	No narrative, no examples — just the essential.

Core Design Principles
	1.	Separation of Data and Operations
	•	Core data models are lightweight and immutable by default.
	•	All heavy computation is in pure, stateless functions or dedicated ops modules.
	2.	Lazy Evaluation + Caching
	•	Derived structures (like CDS blocks, introns) are computed on demand and cached.
	•	Cache is invalidated only if underlying data changes.
	3.	Memory-Efficient Storage
	•	Use numpy arrays for all numeric data (coordinates, block lengths, etc.).
	•	Store genomic blocks (exons, chains) in dense, compact structures optimized for speed and memory.
	4.	Composable Abstractions
	•	Gene → Transcripts → Exons/CDS/UTRs have explicit relationships.
	•	Chain alignments, annotation collections, sequences are first-class objects with consistent APIs.
	5.	Unified I/O Interfaces
	•	I/O parsers return raw objects or collections (e.g., AnnotationCollection, AlignmentChains).
	•	Parsing is format-aware but output is standardized regardless of input format quirks (e.g., BED3 vs BED12).
	6.	Zero-Cost Abstractions
	•	No hidden overhead: what you store is what you operate on.
	•	No copying data unless explicitly requested.
	7.	Optional Acceleration
	•	Critical paths are optimized with Numba.
	•	Optional C-backed dependencies (e.g., py2bit) with Python fallbacks (e.g., twobitreader).
	8.	Minimal Dependencies
	•	Core stack: numpy, numba, optional py2bit or twobitreader.
	•	Everything else is optional or part of dev tooling.
	9.	Format-Agnostic, but User-Friendly
	•	Ability to parse BED, genePred, GTF/GFF, chain, 2bit without depending on external binaries.
	•	Standard methods to save/load from compressed binary formats like .npz for performance.
	10.	Scalable with Data Size
	•	For large files (chains, genomes), support memory-mapped I/O and chunked parsing.
	•	Smart choice of parsing strategy depending on file size.
